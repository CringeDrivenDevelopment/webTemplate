version: '3'

vars:
  GO_VERSION: '1.25.4'
  GOLANGCI_LINT_VERSION: 'v2.6.2'
  GCI_VERSION: 'v0.13.7'
  GOFUMPT_VERSION: 'v0.9.2'
  SWAG_VERSION: 'v1.16.6'
  SQLC_VERSION: 'v1.30.0'
  MOCKERY_VERSION: 'v3.6.1'

  BIN_DIR: '{{.ROOT_DIR}}/bin'
  GOLANGCI_LINT: '{{.BIN_DIR}}/golangci-lint'
  GCI: '{{.BIN_DIR}}/gci'
  GOFUMPT: '{{.BIN_DIR}}/gofumpt'
  MOCKERY: "{{.BIN_DIR}}/mockery"
  SWAG: '{{.BIN_DIR}}/swag'
  SQLC: '{{.BIN_DIR}}/sqlc'

  COVERAGE_DIR: '{{.ROOT_DIR}}/coverage'
  COVERAGE_FILE: total.out

  MODULES: .

tasks:
  install-formatters:
    desc: "Installs gci and gofumpt formatters in ./bin"
    cmds:
      - |
        [ -f {{.GOFUMPT}} ] || {
          mkdir -p {{.BIN_DIR}}
          echo 'üì¶ Installing gofumpt {{.GOFUMPT_VERSION}}...'
          GOBIN={{.BIN_DIR}} go install mvdan.cc/gofumpt@{{.GOFUMPT_VERSION}}
        }
        [ -f {{.GCI}} ] || {
          mkdir -p {{.BIN_DIR}}
          echo 'üì¶ Installing gci {{.GCI_VERSION}}...'
          GOBIN={{.BIN_DIR}} go install github.com/daixiang0/gci@{{.GCI_VERSION}}
        }
    status:
      - test -x {{.GOFUMPT}}
      - test -x {{.GCI}}
  format:
    desc: "Formats the entire project using gofumpt + gci, excluding mocks"
    deps: [ install-formatters ]
    cmds:
      - |
        echo "üéØ Sorting imports with gci ..."
        find . -type f -name '*.go' ! -path '*/mocks/*' -exec {{.GCI}} write -s standard -s default -s "prefix(backend)" {} +
      - |
        echo "üßº Formatting with gofumpt ..."
        find . -type f -name '*.go' ! -path '*/mocks/*' -exec {{.GOFUMPT}} -extra -w {} +

  install-golangci-lint:
    desc: "Installs golangci-lint into the bin directory"
    cmds:
      - |
        [ -f {{.GOLANGCI_LINT}} ] || {
          mkdir -p {{.BIN_DIR}}
          echo "üì¶ Installing golangci-lint {{.GOLANGCI_LINT_VERSION}}..."
          GOBIN={{.BIN_DIR}} go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@{{.GOLANGCI_LINT_VERSION}}
        }
    status:
      - test -x {{.GOLANGCI_LINT}}
  lint:
    desc: "Runs golangci-lint for all modules"
    deps: [ install-golangci-lint ]
    cmds:
      - |
        set -e
        ERR=0
        echo "üîç Linting backend ..."
        {{.GOLANGCI_LINT}} run ./... --config=.golangci.yaml || ERR=1
        exit $ERR

  install-swag:
    desc: "installs swagger"
    cmds:
      - |
        [ -f {{.SWAG}} ] || {
          mkdir -p {{.BIN_DIR}}
          echo "üì¶ Installing swag {{.SWAG_VERSION}}..."
          GOBIN={{.BIN_DIR}} go install github.com/swaggo/swag/cmd/swag@{{.SWAG_VERSION}}
        }
    status:
      - test -x {{.SWAG}}
  swag:
    desc: "Generates swagger based on go-code"
    deps: [ install-swag ]
    cmds:
      - |
        {{.SWAG}} init -g cmd/main.go

  mockery:install:
    desc: "Install mockery in ./bin"
    cmds:
      - |
        [ -f {{.MOCKERY}} ] || {
          echo 'üì¶ Installing mockery...'
          GOBIN={{.BIN_DIR}} go install github.com/vektra/mockery/v3@{{.MOCKERY_VERSION}}
        }
    status:
      - test -x {{.MOCKERY}}

  mockery:gen:
    desc: "Generates interface mocks via mockery"
    deps: [ mockery:install ]
    cmds:
      - |
        echo 'üß™ Generating mocks...'
        {{.MOCKERY}}

  test:
    desc: "Runs unit tests"
    cmds:
      - |
        ERR=0
        go test -v ./... || ERR=1
        exit $ERR

  test-coverage:
    desc: "Tests with business logic coverage (service/repository)"
    cmds:
      - |
        echo "üß™ –ó–∞–ø—É—Å–∫–∞–µ–º —Ä–∞—Å—á—ë—Ç –ø–æ–∫—Ä—ã—Ç–∏—è..."
        rm -rf {{.COVERAGE_DIR}}
        mkdir -p {{.COVERAGE_DIR}}
        
        ERR=0
        for mod in {{.MODULES}}; do
          echo "üì¶ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –º–æ–¥—É–ª—å: $mod"
        
          TARGET_PKGS=$(go list ./$mod/... \
            | grep -E '/(internal/(service|repository))' \
            | grep -vE '/(mocks|testdata|pkg|api|proto|pb|cmd)' \
            | paste -sd "," -)
        
          if [ -z "$TARGET_PKGS" ]; then
            echo "‚ö†Ô∏è  –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø–∞–∫–µ—Ç–æ–≤ –≤ $mod"
            continue
          fi
        
          go test -coverpkg="$TARGET_PKGS" \
            -coverprofile={{.COVERAGE_DIR}}/$mod.out \
            -covermode=atomic \
            $(echo "$TARGET_PKGS" | tr "," " ") || ERR=1
        done
        
        if [ $ERR -ne 0 ]; then
          echo "‚ùå –û—à–∏–±–∫–∏ –≤–æ –≤—Ä–µ–º—è —Ç–µ—Å—Ç–æ–≤"
          exit $ERR
        fi
        
        echo
        echo "üìä –ü–æ–∫—Ä—ã—Ç–∏–µ –ø–æ –∫–∞–∂–¥–æ–º—É –º–æ–¥—É–ª—é:"
        for mod in {{.MODULES}}; do
          OUTFILE="{{.COVERAGE_DIR}}/$mod.out"
          if [ -f "$OUTFILE" ]; then
            printf " ‚Ä¢ %s: " "$mod"
            go tool cover -func="$OUTFILE" | tail -n1
          fi
        done
        
        echo
        echo "üì¶ –°–∫–ª–µ–∏–≤–∞–µ–º –≤—Å–µ –ø–æ–∫—Ä—ã—Ç–∏—è..."
        {
          echo "mode: atomic"
          find {{.COVERAGE_DIR}} -type f -name '*.out' ! -name '{{.COVERAGE_FILE}}' \
            -exec grep -h -v "^mode:" {} +
        } > {{.COVERAGE_DIR}}/{{.COVERAGE_FILE}}
        
        echo
        echo "üßæ –û–±—â–µ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ –ø–æ –≤—Å–µ–º –º–æ–¥—É–ª—è–º:"
        go tool cover -func={{.COVERAGE_DIR}}/{{.COVERAGE_FILE}} | tail -n1
  

  dcu:
    cmds:
      - docker compose -f dev-compose.yml up -d
  dcd:
    cmds:
      - docker compose -f dev-compose.yml down
